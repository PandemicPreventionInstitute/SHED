"""
Written by Devon Gregory
This snakefile is meant to be run via snakemake to perform the
query and SRA download for the bioinformatics pipeline.
Last edited on 5-21-23
"""
import os
import time
#from snakemake.utils import min_version

#min_version("7.8.0")

snakepath = os.path.realpath(sys.path[0])
configfile: f"{snakepath}/config.yaml"

include: f"{snakepath}/modules/snakefunctions.py"

# dertermine working dir path
if not config["work_path"]:
    config["work_path"] = os.getcwd()
workdir: config["work_path"]

# query SRA, get the meta data and pull accessions from it
if config["query"]:
    if config["run_ID"]:
        RUN_ID = config["run_ID"]
    else:
        RUN_ID = time.time()
    sra_query(config["query"], RUN_ID, config["overwrite"])
    parse_xml_meta(RUN_ID, config["overwrite"])

acc_list = get_sample_acc1(config["reprocess"])

config["overwrite"] = False

rule all:
    """
    Establishes targets for snakemake and initial wildcard values
    """
    input:
        expand("sams/{sra_acc}.bam.done", sra_acc=acc_list),

rule download_sra:
    """
    Downloads the sra files for the samples collected in the query
    using NCBI's SRA Tools prefetch, catches accession with no data to download,
    otherwise errors cause an exit
    """
    output:
        temp(touch("SRAs/{sra_acc}.sra.done")),
    log:
        "logs/{sra_acc}.sra.log",
    resources: download_streams=1,
    shell:
        """
        set +e
        if [[ ! -d SRAs ]]
        then
        mkdir SRAs
        fi
        prefetch {wildcards.sra_acc} -O SRAs >>{log} 2>&1
        exitcode=$?
        if [ $exitcode -eq 3 ]
        then
            touch 'SRAs/'{wildcards.sra_acc}'.no.data'
        elif [ $exitcode -ne 0 ]
        then
            echo "prefetch failed with exitcode:"
            echo "$exitcode"
            exit 1
        fi
        """


rule get_fastqs:
    """
    Writes the fastq files for the samples collected in the query
    using NCBI's SRA Tools fasterq-dump.  Reads will be split into
    seperate files for forward and reverse paired end, and single end
    reads.  Unpaired reads from paired end sequencing (very rare)
    won't be processed past qc.
    """
    input:
        rules.download_sra.output,
    output:
        temp(touch("fastqs/{sra_acc}.fq.done")),
    log:
        "logs/{sra_acc}.fq.log",
    shell:
        """
        set +e

        cd SRAs

        fasterq-dump --split-files -f -O ../fastqs {wildcards.sra_acc} >>../{log} 2>&1
        exitcode=$?
        if [ $exitcode -eq 3 ]
        then
            touch '../fastqs/'{wildcards.sra_acc}'.no.data'
        elif [ $exitcode -ne 0 ]
        then
            echo "prefetch failed with exitcode:"
            echo "$exitcode"
            exit 1
        fi
        """


rule quality_check:
    """
    Checks the quality of the reads using fastp.  Reads are trimmed of detected
    adapters, 25 5' nts if sequencing primers haven't been determined, and
    quality trimmed.  Sequences not at least 50 nts long are culled.
    fastp defaults are otherwise used.
    """
    input:
        rules.get_fastqs.output,
    output:
        temp(touch("fastqs/{sra_acc}.qc.done")),
    params:
        gen="--dont_eval_duplication -5 -3 -l 50 ",
        cutting=lambda wildcards: acc_list[wildcards.sra_acc]["cut"],
    log:
        "logs/{sra_acc}.qc.log",
    threads: 3
    conda:
        "envs/fastp.yaml"
    shell:
        """
        if [[ -f fastqs/{wildcards.sra_acc}.fastq ]]
        then
        fastp {params.gen}{params.cutting}-i fastqs/{wildcards.sra_acc}.fastq -o fastqs/{wildcards.sra_acc}.qc.fq \
        -j fastqs/{wildcards.sra_acc}.se.json -h fastqs/{wildcards.sra_acc}.se.html >>{log} 2>&1
        fi
        if [[ -f fastqs/{wildcards.sra_acc}_1.fastq ]]
        then
        fastp --detect_adapter_for_pe {params.gen}{params.cutting}-i fastqs/{wildcards.sra_acc}_1.fastq \
        -I fastqs/{wildcards.sra_acc}_2.fastq -o fastqs/{wildcards.sra_acc}_1.qc.fq -O fastqs/{wildcards.sra_acc}_2.qc.fq \
        -j fastqs/{wildcards.sra_acc}.pe.json -h fastqs/{wildcards.sra_acc}.pe.html >>{log} 2>&1
        fi
        """


rule mapping:
    """
    mapping of quality checked reads using minimap2 against the
    reference SARS-CoV-2 Wuhan-Hu-1 sequence using the short read
    presets (No wastewater sequences seem to have long reads)
    Checks for both paired end and single end files
    """
    input:
        "fastqs/{sra_acc}.qc.done",
        fa=f"{snakepath}/data/SARS2.fasta",
    output:
        temp(touch("sams/{sra_acc}.sam.done")),
    log:
        "logs/{sra_acc}.mapping.log",
    threads: 4
    conda:
         "envs/minimap2.yaml"
    shell:
        """
        if [[ -f fastqs/{wildcards.sra_acc}_1.qc.fq && -f fastqs/{wildcards.sra_acc}_2.qc.fq ]]
        then
        minimap2 -ax sr {input.fa} fastqs/{wildcards.sra_acc}_1.qc.fq fastqs/{wildcards.sra_acc}_2.qc.fq \
        -o sams/{wildcards.sra_acc}.sam --secondary=no --sam-hit-only >>{log} 2>&1
        elif [[ -f fastqs/{wildcards.sra_acc}.qc.fq ]]
        then
        minimap2 -ax sr {input.fa} fastqs/{wildcards.sra_acc}.qc.fq \
        -o sams/{wildcards.sra_acc}.sam --secondary=no --sam-hit-only >>{log} 2>&1
        fi
        """

rule qc_pass_check:
    """
    check to see if enough reads mapped to be worth continuing
    """
    input:
        rules.mapping.output,
    output:
        temp(touch("sams/{sra_acc}.qc_pass.done")),
    run:
        if qc_pass(wildcards.sra_acc):
            shell("touch sams/{wildcards.sra_acc}.qc.passed")
        else:
            shell("touch sams/{wildcards.sra_acc}.qc.failed")

rule sam2bam:
    """
    convert, sort and index the sams to bams using samtools (comes with ivar)
    """
    input:
        rules.qc_pass_check.output,
        rules.mapping.output,
    output:
        temp(touch("sams/{sra_acc}.bam.done")),
    log:
        "logs/{sra_acc}.bam.log",
    conda:
        "envs/freyja.yaml"
    threads: 4
    shell:
        """
        if [[ -f sams/{wildcards.sra_acc}.qc.passed ]]
        then
        samtools sort sams/{wildcards.sra_acc}.sam -o sams/{wildcards.sra_acc}.bam -@ 4 >>{log} 2>&1
        samtools index sams/{wildcards.sra_acc}.bam >>{log} 2>&1
        fi
        """
